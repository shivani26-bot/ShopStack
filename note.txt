first set up monorepo from nx.dev
npx create-nx-workspace@20 .     run command in terminal

Which stack do you want to use? · node
✔ What framework should be used? · express
? Application name › auth-service 
Would you like to generate a Dockerfile? [https://docs.docker.com/] · Yes
✔ Which unit test runner would you like to use? · jest
✔ Would you like to use ESLint? · No
✔ Would you like to use Prettier for code formatting? · No
 Which CI provider would you like to use? · github

It will create our workspace, with .nx, .vscode, node_modules, package.json, package-lock.json,packages, .gitignore

e2e -> end to end testing

Use version 20 of monorepo nx.dev https://20.nx.dev/nx-api/express
https://20.nx.dev/showcase/example-repos/add-express
nx add @nx/express
nx g @nx/express:app apps/my-express-api-> to add more services to our project
nx g @nx/express:app api-gateway --directory=apps/api-gateway --e2eTestRunner=none
nx g @nx/express:app: Generates a new Express.js app using Nx's Express plugin.
api-gateway: This is the name of the app.
--directory=apps/api-gateway: Places the generated app in the apps/api-gateway folder.
--e2eTestRunner=none: Disables generation of end-to-end (E2E) tests.

✔ Which linter would you like to use? · none
✔ Which unit test runner would you like to use? · none

Inside apps folder we can see our service and test service 

nx add @nx/express
zsh: command not found: nx 
nx CLI isn't installed globally or your terminal can't find it in the current environment.

Either use npx nx add @nx/express
Or install nx cli: npm install -g nx. Then use nx commands directly


    "dev":"npx nx run-many --target=serve --all" if we do nam run dev, it will run all the services in the apps folder

npm i express-http-proxy. : for reverse proxy in api-gateway

npm i cors morgan express-rate-limit swagger-ui-express axios cookie-parser
cors – Enables Cross-Origin Resource Sharing to allow or restrict resources on a web server from different domains.
morgan – Logs HTTP requests for monitoring and debugging purposes.
express-rate-limit – Limits repeated requests from the same IP to protect APIs from abuse (e.g., DoS attacks).
swagger-ui-express – Serves Swagger UI for API documentation within an Express app.
axios – A promise-based HTTP client for making API requests from both the browser and Node.js.
cookie-parser – Parses cookies attached to the client request object for easier access and management.


npx kill-port port_number


curl http://localhost:8080 : it will forward the request to  service with / route


packages folder-> error-handler folder and middleware

add this ip in network access in mongodb :0.0.0.0/0 with this ip we are giving permission that Anyone can access the database from anywhere in the world
this will help all the services to access the database

prisma setup
npm i prisma @prisma/client:for database
npx prisma init: will create  prisma folder in root directory
npx prisma db push :pushes the models/tables directly to database used (mongodb here, you can see the tables there)
set up prisma/client in packages libs prisma index.ts, to use prisma to query database


npm install crypto ioredis nodemailer dotenv ejs
crypto:
Used for:Password hashing,Creating OTPs or tokens,Encryption/decryption
ioredis: Redis client for Node.js
Used for:Caching,Storing OTPs or sessions,Pub/Sub (real-time apps),Rate limiting
nodemailer: Sending emails from a Node.js backend
dotenv: Load environment variables from a .env file
Keeping secrets out of code,Accessing config via process.env
ejs (Embedded JavaScript Templates): Templating engine for rendering HTML with dynamic data

If you are using Node.js 15.x or higher
You do not need to install crypto — it’s built into Node.js as a core module.


redis setup
Using upstash for redis ui
login and create a database there, provide name, and region
we get redis host port password from there


go to gmail account, search for app passwords, give app name, this will give smtp password is app password, and user 

npm i swagger-autogen:tool that helps automatically generate Swagger (OpenAPI) documentation from your Express routes and JSDoc comments.
make a swagger.js file in src of your dedicated service, configure swagger there
then get inside the folder through terminal and run command 
to generate swagger file : cd auth-service cd src, run node swagger.js, it will create the swagger documentation 
we can edit swagger-output.json , name and email there

resolve the issue Cannot find module './swagger-output.json':
in auth-service 
edit package.json file, add webpack.config.js file ,delete dist folder ,.nx folder rerun the command npm run dev
to setup alias for filenames like ../../../../packages/pathname to @packages/libs/prisma , add resolve field to webpack.config.js also make changes to tsconfig.base.json in root folder add baseUrl and paths filed

run this command npx nx run-many --target=serve --all --verbose if failed to process the project graph error occurs
npx nx reset cache: 
Deletes the .nx/cache folder
Forces NX to rebuild the project graph from scratch the next time you run a command
Helps if builds/serve commands fail due to stale artifacts or incorrect dependency graph

You’d typically run it when:
You renamed/moved project folders
You changed tsconfig paths
NX is giving weird “failed to process project graph” errors


webpack.config.js:instruction manual you give to Webpack so it knows how to bundle your project.Without it, Webpack can still run with default settings.
Webpack is a machine that:
Starts from your entry file (like src/index.ts)
Follows every import/require
Transforms your code (TypeScript → JS, JSX → JS, Sass → CSS, etc.)
Optimizes it (minification, tree-shaking)
Outputs a single (or multiple) bundled files.


npm i bcryptjs jsonwebtoken : 
bcryptjs → Pure JavaScript implementation of bcrypt for hashing passwords.
jsonwebtoken → Library to sign and verify JWT (JSON Web Tokens) for authentication.


whenever you make any change to prisma schema run:
npx prisma db push


after adding any routes to route folder run the node swagger.js file again for that service
npm run auth-docs 
in swagger-output.json, basebath should be /api 
npm i --save-dev @types/jsonwebtoken


https://jwtsecrets.com/ use this website to generate jwt secret key
here we are using 32 bits in our project

setting up frontend
go to nx.dev, go to docs, select v20, then go to next.js
run this command: nx add @nx/next
create new project: nx g @nx/next:app apps/my-new-app
Which stylesheet format would you like to use? · tailwind

✔ Which linter would you like to use? · none
✔ What unit test runner should be used? · none
✔ Which E2E test runner would you like to use? · none
✔ Would you like to use the App Router (recommended)? (Y/n) · true
✔ Would you like to use `src/` directory? (Y/n) · true

add script user-ui in root package.json


creating seller-ui
https://20.nx.dev/nx-api/next select v20
nx g @nx/next:app apps/seller-ui (will create seller-ui folder in apps folder)
✔ What unit test runner should be used? · none
✔ Which E2E test runner would you like to use? · none
✔ Would you like to use the App Router (recommended)? (Y/n) · true
✔ Would you like to use `src/` directory? (Y/n) · true
create a script for seller-ui in package.json


npm i stripe
go to stripe dashboard, search api keys, copy the secret key form there in  test mode
we can also roll or rotate the api keys , this will create a new api key for us

in this project we are using Next.js 13+ App Router project (since you’re using src/app)
Inside (routes) you’re creating folders
Each folder inside (routes) corresponds to a route.
src/app/(routes)/dashboard/page.tsx   → /dashboard
src/app/(routes)/auth/login/page.tsx  → /auth/login
A page.tsx defines the UI for that route.
It’s like your entry point for a route.
A layout.tsx defines the shared layout for that folder’s route segment.
All pages inside that folder will use this layout unless overridden by a deeper layout.tsx.
src/app/(routes)/dashboard/layout.tsx
src/app/(routes)/dashboard/page.tsx
The layout.tsx will wrap around the dashboard’s page.tsx


npm i react-quill-new:React wrapper for Quill editor


nmp i node-cron for implementing node cron jobs
npm i --save-dev @types/node-cron



serve is
serve is a target or task defined in a project’s configuration (project.json or workspace.json) that starts the project in development mode.
Usually, it starts a local server for an app so you can run it, test it, and see changes live.

npx nx run-many --target=serve --all

--all runs the serve target for all projects that have it defined in workspace.json (or project.json).
So if some “services” don’t have serve, NX skips them silently.
By default, run-many runs projects sequentially.
serve usually starts a server and never exits.
That means if you run sequentially:
NX starts project A → server runs → never exits
NX never reaches project B, C, etc.
This is why only the first project actually starts.

npx nx run-many --target=serve --all --parallel=<number>  by default number=3
Starts multiple serve targets at the same time, so all servers run concurrently.
The number should be >= number of apps you want to start.


schema for chatting 
model conversationGroup {
  id             String   @id @default(auto()) @map("_id") @db.ObjectId
  isGroup        Boolean  @default(false)
  name           String?
  creatorId      String
  participantIds String[] @db.ObjectId
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

What it represents:
This is a chat conversation (can be one-to-one or a group).
For 1-to-1 chats, isGroup = false.
For group chats, isGroup = true and name will hold the group name.

Fields:
id → Unique MongoDB ObjectId for the conversation.
isGroup → Boolean flag (true = group chat, false = direct chat).
name → Optional. Only relevant if it's a group.
creatorId → User who created this conversation (admin in case of groups).
participantIds → Array of ObjectIds of all users/sellers in the chat.
createdAt → Timestamp when the conversation was created.
updatedAt → Auto-updated whenever the record changes.

model participant {
  id             String    @id @default(auto()) @map("_id") @db.ObjectId
  conversationId String    @db.ObjectId
  userId         String?   @db.ObjectId
  sellerId       String?   @db.ObjectId
  lastSeenAt     DateTime?
  isOnline       Boolean   @default(false)
  unreadCount    Int       @default(0)
  muted          Boolean   @default(false)
  joinedAt       DateTime  @default(now())
}

What it represents:
This is a linking table that tracks each participant’s state inside a conversation.
Instead of just having participantIds in conversationGroup, this model stores per-user metadata like unread count, online status, etc.

Fields:
id → Unique MongoDB ObjectId for participant entry.
conversationId → The conversation this participant belongs to.
userId → If the participant is a user.
sellerId → If the participant is a seller (one of the actors in your app).
lastSeenAt → When this participant last read the conversation.
isOnline → Whether the participant is currently connected via WebSocket.
unreadCount → How many messages are unread for this participant.
muted → If the participant muted notifications for this conversation.
joinedAt → When the participant joined the chat.
👉 Think of this as "per-user settings and tracking inside a chat

model message {
  id             String   @id @default(auto()) @map("_id") @db.ObjectId
  conversationId String   @db.ObjectId
  senderId       String   @db.ObjectId
  senderType     String
  content        String?
  attachments    String[]
  status         String   @default("sent")
  createdAt      DateTime @default(now())

  @@unique([conversationId, senderId, content, createdAt])
}

What it represents:
Each individual chat message inside a conversation.

Fields:
id → Unique MongoDB ObjectId for the message.
conversationId → Which conversation this message belongs to.
senderId → The user/seller who sent the message.
senderType → "user" or "seller".
content → Actual text message (nullable if only attachment is sent).
attachments → Array of file URLs (images, docs, etc.).
status → "sent", "delivered", "seen". (Default = "sent").
createdAt → Timestamp when the message was created.
@@unique([...]) → Ensures uniqueness so that duplicate messages (same content, sender, and timestamp) are not stored.

conversationGroup → Represents a chat session (either 1-to-1 or group).
participant → Represents who is in that chat and tracks per-user data like unread counts.
message → Represents each individual message in a conversation.


we are using pnpm , we get extra command in docker file which help us to build our project

create a sample .env.example file in root directory which represents the structure of .env file